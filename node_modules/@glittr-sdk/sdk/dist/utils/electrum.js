"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.electrumFetchNonGlittrUtxos = exports.electrumFetchTxHex = void 0;
const asset_1 = require("../helper/asset");
const fetch_1 = require("./fetch");
const electrumFetchTxHex = async (electrumApiUrl, apiKey, txId) => {
    try {
        const txHex = await (0, fetch_1.fetchGET)(`${electrumApiUrl}/tx/${txId}/hex`, { Authorization: `Bearer ${apiKey}` });
        return txHex;
    }
    catch (e) {
        throw new Error(`Error fetching TX Hex : ${e}`);
    }
};
exports.electrumFetchTxHex = electrumFetchTxHex;
const electrumFetchNonGlittrUtxos = async (client, address) => {
    try {
        const unconfirmedUtxos = await (0, fetch_1.fetchGET)(`${client.electrumApi}/address/${address}/utxo`, { Authorization: `Bearer ${client.apiKey}` }) ?? [];
        const utxos = unconfirmedUtxos.filter((tx) => tx.status && tx.status.confirmed);
        const nonGlittrUtxos = [];
        for (const utxo of utxos) {
            const assetString = await (0, asset_1.getGlittrAsset)(client, utxo.txid, utxo.vout);
            const asset = JSON.parse(assetString);
            const assetIsEmpty = !asset.assets ||
                !asset.assets.list ||
                Object.keys(asset.assets.list).length === 0;
            if (assetIsEmpty) {
                nonGlittrUtxos.push(utxo);
            }
        }
        return nonGlittrUtxos;
    }
    catch (e) {
        throw new Error(`Error fetching Non Glittr UTXOS : ${e}`);
    }
};
exports.electrumFetchNonGlittrUtxos = electrumFetchNonGlittrUtxos;
