"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeVarint = exports.encodeVarint = void 0;
const const_1 = require("../helper/const");
function encodeVarint(t) {
    let n = BigInt(t);
    if (n > const_1.I128_MAX_NUMBER) {
        throw new Error(`Can't encode value more than ${const_1.I128_MAX_NUMBER}`);
    }
    if (n < const_1.I128_MIN_NUMBER) {
        throw new Error(`Can't encode value less than ${const_1.I128_MIN_NUMBER}`);
    }
    // zigzag encoding to convert it into unsigned
    let unsigned = 0n;
    if (n > 1n) {
        // positive
        unsigned = n << 1n;
    }
    else if (n !== 0n) {
        // negative
        unsigned = (-n << 1n) - 1n;
    }
    n = unsigned;
    const arr = new Uint8Array(const_1.BUFFER_MAX_VARUINT_LENGTH);
    let i = 0;
    while (n >> 7n > 0) {
        arr[i] = Number((n & 255n) | 128n);
        n >>= 7n;
        i += 1;
    }
    arr[i] = Number(n);
    return arr.slice(0, i + 1);
}
exports.encodeVarint = encodeVarint;
function decodeVarint(buffer) {
    let finalValue = BigInt(0);
    for (let i = 0; i < buffer.length; i += 1) {
        const byte = buffer[i];
        const value = byte & 127;
        finalValue = finalValue | (BigInt(value) << (7n * BigInt(i)));
    }
    if (finalValue < 0n) {
        // this can't be happen, just for safety
        throw new Error("Value is minus, something wrong");
    }
    if (finalValue == 0n) {
        return finalValue;
    }
    // zigzag encoding to convert it into signed
    if ((finalValue & 1n) == 1n) {
        // negative
        return -((finalValue + 1n) >> 1n);
    }
    else {
        // positive
        return finalValue >> 1n;
    }
}
exports.decodeVarint = decodeVarint;
