"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encryptMessage = exports.encodeGlittrData = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const secp256k1_1 = require("@noble/curves/secp256k1");
const sha256_1 = require("@noble/hashes/sha256");
function encodeGlittrData(message) {
    const glittrFlag = Buffer.from("GLITTR", "utf8"); // Prefix
    const glittrData = Buffer.from(message, "utf8");
    const embed = bitcoinjs_lib_1.script.compile([106, glittrFlag, glittrData]);
    return embed;
}
exports.encodeGlittrData = encodeGlittrData;
async function encryptMessage(publicKeyBytes, message) {
    const ephemeralPrivateKey = secp256k1_1.secp256k1.utils.randomPrivateKey();
    const ephemeralPublicKey = secp256k1_1.secp256k1.getPublicKey(ephemeralPrivateKey);
    const publicKey = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKeyBytes);
    // Simplified ECDH calculation
    const sharedSecret = publicKey.multiply(BigInt('0x' + Buffer.from(ephemeralPrivateKey).toString('hex'))).toRawBytes();
    const symmetricKey = (0, sha256_1.sha256)(sharedSecret);
    const nonce = crypto.getRandomValues(new Uint8Array(12));
    const key = await crypto.subtle.importKey('raw', symmetricKey, { name: 'AES-GCM' }, false, ['encrypt']);
    const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: nonce }, key, new TextEncoder().encode(message));
    // Combine all components
    return Buffer.concat([
        Buffer.from(ephemeralPublicKey),
        nonce,
        new Uint8Array(ciphertext)
    ]);
}
exports.encryptMessage = encryptMessage;
