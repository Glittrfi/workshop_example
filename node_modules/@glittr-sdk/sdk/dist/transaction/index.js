"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.txBuilder = void 0;
const borsh_1 = require("@glittr-sdk/borsh");
const schema_1 = require("./schema");
const brotli_compress_1 = require("brotli-compress");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const utils_1 = require("../utils");
const convert_1 = require("./convert");
class TxBuilderClass {
    constructor() { }
    static transfer(params) {
        return {
            transfer: {
                transfers: params.transfers,
            },
        };
    }
    static contractCall(params) {
        return {
            contract_call: {
                contract: params.contract,
                call_type: params.call_type,
            },
        };
    }
    static contractInstantiate(params) {
        if (params.burn_mechanism) {
            return {
                contract_creation: {
                    contract_type: {
                        mba: {
                            divisibility: params.divisibility,
                            live_time: params.live_time,
                            supply_cap: params.supply_cap,
                            ticker: params.ticker,
                            mint_mechanism: params.mint_mechanism,
                            burn_mechanism: params.burn_mechanism,
                            swap_mechanism: {}, // TODO
                        },
                    },
                },
            };
        }
        else {
            return {
                contract_creation: {
                    contract_type: {
                        moa: {
                            divisibility: params.divisibility,
                            live_time: params.live_time,
                            supply_cap: params.supply_cap,
                            ticker: params.ticker,
                            mint_mechanism: params.mint_mechanism,
                        },
                    },
                },
            };
        }
    }
    static freeMint(params) {
        return {
            contract_creation: {
                contract_type: {
                    moa: {
                        divisibility: params.divisibility,
                        live_time: params.live_time,
                        ticker: params.ticker,
                        supply_cap: params.supply_cap,
                        mint_mechanism: {
                            free_mint: {
                                amount_per_mint: params.amount_per_mint,
                                supply_cap: params.supply_cap,
                            },
                        },
                    },
                },
            },
        };
    }
    static paidMint(params) {
        return {
            contract_creation: {
                contract_type: {
                    moa: {
                        divisibility: params.divisibility,
                        live_time: params.live_time,
                        ticker: params.ticker,
                        supply_cap: params.supply_cap,
                        mint_mechanism: {
                            purchase: {
                                input_asset: params.payment.input_asset,
                                pay_to_key: params.payment.pay_to,
                                ratio: params.payment.ratio,
                            },
                        },
                    },
                },
            },
        };
    }
    static createPool(params) {
        return {
            contract_creation: {
                contract_type: {
                    mba: {
                        divisibility: params.divisibility,
                        live_time: params.live_time,
                        supply_cap: params.supply_cap,
                        mint_mechanism: {
                            collateralized: {
                                _mutable_assets: true,
                                input_assets: params.assets,
                                mint_structure: {
                                    proportional: {
                                        ratio_model: "constant_product",
                                        inital_mint_pointer_to_key: params.initial_mint_restriction, // TODO exclude only if no params
                                    },
                                },
                            },
                        },
                        burn_mechanism: {
                            return_collateral: {}, // TODO
                        },
                        swap_mechanism: {}, // TODO
                    },
                },
            },
        };
    }
    static customMessage(params) {
        return params;
    }
    static compile(message) {
        if (!message || Object.keys(message).length === 0) {
            throw new Error("No message to compile");
        }
        return (0, utils_1.encodeGlittrData)(JSON.stringify(message));
    }
    static async compress(message) {
        const VERSION = 0;
        try {
            if (!message || Object.keys(message).length === 0) {
                throw new Error("No message to compile");
            }
            const encoded = (0, borsh_1.serialize)(schema_1.schema, (0, convert_1.transformOpReturnMessage)(message));
            const compressed = await (0, brotli_compress_1.compress)(encoded);
            const useCompressed = encoded.length > compressed.length;
            let data = encoded;
            if (useCompressed) {
                data = compressed;
            }
            const header = new utils_1.Header(VERSION, useCompressed);
            const payload = Buffer.concat([header.toBytes(), data]);
            const glittrFlag = Buffer.from("GLITTR", "utf8"); // Prefix
            const embed = bitcoinjs_lib_1.script.compile([106, glittrFlag, payload]);
            return embed;
        }
        catch (error) {
            throw new Error(`Error compiling OP_RETURN message ${error}`);
        }
    }
}
exports.txBuilder = TxBuilderClass;
__exportStar(require("./types"), exports);
__exportStar(require("./message"), exports);
__exportStar(require("./auto"), exports);
__exportStar(require("./schema"), exports);
