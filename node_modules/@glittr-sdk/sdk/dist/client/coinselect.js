"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dustThreshold = exports.coinSelect = exports.FEE_TX_OUTPUT_TAPROOT = exports.FEE_TX_OUTPUT_SEGWIT_SCRIPTHASH = exports.FEE_TX_OUTPUT_SEGWIT = exports.FEE_TX_OUTPUT_SCRIPTHASH = exports.FEE_TX_OUTPUT_PUBKEYHASH = exports.FEE_TX_OUTPUT_BASE = exports.FEE_TX_INPUT_TAPROOT = exports.FEE_TX_INPUT_SEGWIT_SCRIPTHASH = exports.FEE_TX_INPUT_SEGWIT = exports.FEE_TX_INPUT_SCRIPTHASH = exports.FEE_TX_INPUT_PUBKEYHASH = exports.FEE_TX_INPUT_BASE = exports.FEE_TX_EMPTY_SIZE = void 0;
const bitcoin_address_validation_1 = require("bitcoin-address-validation");
const address_1 = require("../utils/address");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const electrum_1 = require("../utils/electrum");
const fee_1 = require("../helper/fee");
const fetch_1 = require("../utils/fetch");
const utils_1 = require("../utils");
exports.FEE_TX_EMPTY_SIZE = 4 + 1 + 1 + 4;
exports.FEE_TX_INPUT_BASE = 32 + 4 + 1 + 4;
exports.FEE_TX_INPUT_PUBKEYHASH = 107;
exports.FEE_TX_INPUT_SCRIPTHASH = 1; // calculate based on script length
exports.FEE_TX_INPUT_SEGWIT = 27 + 1;
exports.FEE_TX_INPUT_SEGWIT_SCRIPTHASH = 0; // calculate based on script length
exports.FEE_TX_INPUT_TAPROOT = 17 + 1;
exports.FEE_TX_OUTPUT_BASE = 8 + 1;
exports.FEE_TX_OUTPUT_PUBKEYHASH = 25;
exports.FEE_TX_OUTPUT_SCRIPTHASH = 23;
exports.FEE_TX_OUTPUT_SEGWIT = 22;
exports.FEE_TX_OUTPUT_SEGWIT_SCRIPTHASH = 34;
exports.FEE_TX_OUTPUT_TAPROOT = 34;
function _sumValues(data) {
    // @ts-ignore
    return data?.reduce((prev, input) => prev + (input.value || 0), 0);
}
function _isTxContainsOnlyTransfer(tx) {
    // Check if tx has exactly one key and it's 'transfer'
    const keys = Object.keys(tx);
    if (keys.length === 1 && keys[0] === "transfer" && tx.transfer?.transfers) {
        return tx.transfer.transfers.map((transfer) => ({
            asset: transfer.asset,
            amount: transfer.amount,
        }));
    }
    return null;
}
function _isTxContainsMintContractCall(tx) {
    if (tx.contract_call &&
        tx.contract_call.call_type &&
        "mint" in tx.contract_call.call_type) {
        const mintCall = tx.contract_call.call_type.mint;
        return {
            contract: tx.contract_call.contract,
            pointer: mintCall.pointer,
        };
    }
    return null;
}
async function coinSelect(client, inputs, outputs, feeRate, address, tx, changeOutputAddress, publicKey) {
    let txBytes = (0, fee_1.getTransactionBytes)(inputs, outputs);
    let totalInputValue = inputs.reduce((prev, input) => prev + input.value, 0);
    const totalOutputValue = outputs.reduce((prev, output) => prev + output.value, 0);
    let totalFee = feeRate * txBytes;
    // if (totalInputValue < totalOutputValue + totalFee) {
    //   return;
    // }
    const utxos = await (0, electrum_1.electrumFetchNonGlittrUtxos)(client, address);
    const fetchGlittrAsset = async (txId, vout) => {
        try {
            const asset = await (0, fetch_1.fetchGET)(`${client.glittrApi}/assets/${txId}/${vout}`, { Authorization: `Bearer ${client.apiKey}` });
            return JSON.stringify(asset);
        }
        catch (e) {
            throw new Error(`Error fetching Glittr Asset : ${e}`);
        }
    };
    // Separate UTXOs based on asset presence
    const utxosGlittr = [];
    const nonUtxosGlittr = [];
    for (const utxo of utxos) {
        const assetString = await fetchGlittrAsset(utxo.txid, utxo.vout);
        const asset = JSON.parse(assetString);
        const assetIsEmpty = !asset.assets ||
            !asset.assets.list ||
            Object.keys(asset.assets.list).length === 0;
        if (assetIsEmpty) {
            nonUtxosGlittr.push(utxo);
        }
        else {
            // Convert the asset list object into the required format
            const glittrUtxo = {
                ...utxo,
                assets: Object.entries(asset.assets.list).map(([assetId, amount]) => ({
                    asset: assetId,
                    amount: amount,
                })),
            };
            utxosGlittr.push(glittrUtxo);
        }
    }
    const addUtxosToInputs = (utxosList, feeRate) => {
        for (const utxo of utxosList) {
            const utxoBytes = (0, fee_1.getInputBytes)(utxo);
            const utxoFee = feeRate * utxoBytes;
            const utxoValue = utxo.value;
            if (utxoFee > utxoValue)
                continue;
            txBytes += utxoBytes;
            totalInputValue += utxoValue;
            inputs.push(utxo);
            if (totalInputValue >= totalOutputValue + totalFee)
                break;
        }
    };
    if (_isTxContainsOnlyTransfer(tx)) {
        const transferAssets = _isTxContainsOnlyTransfer(tx);
        if (!transferAssets)
            throw new Error("Transfer TX invalid");
        // Filter utxosGlittr to only include UTXOs that contain the required transfer assets
        const relevantUtxos = utxosGlittr.filter((utxo) => {
            return transferAssets?.some((transfer) => utxo.assets?.some((asset) => Array.isArray(transfer.asset) &&
                asset.asset === `${transfer.asset[0]}:${transfer.asset[1]}`
            // && BigInt(asset.amount) >= BigInt(transfer.amount)
            ));
        });
        addUtxosToInputs(relevantUtxos, feeRate);
        // Handle if input asset is enough or more
        const getInputAssetSum = (assetId) => {
            return inputs.reduce((sum, input) => {
                const matchingAsset = input.assets?.find((a) => a.asset === assetId);
                return sum + BigInt(matchingAsset?.amount || 0);
            }, BigInt(0));
        };
        // Check if glittr asset inputs are enough
        for (const { asset, amount } of transferAssets) {
            const _amount = (0, utils_1.decodeVaruint)(amount);
            const assetId = `${asset[0]}:${asset[1]}`;
            // If input asset is enough, continue to next asset
            if (getInputAssetSum(assetId) === BigInt(_amount)) {
                continue;
            }
            // Loop through relevant UTXOs till input asset is enough or more
            for (const utxo of relevantUtxos) {
                if (getInputAssetSum(assetId) >= BigInt(_amount))
                    break;
                if (inputs.some((input) => input.txid === utxo.txid))
                    continue;
                addUtxosToInputs([utxo], feeRate);
            }
            // If input asset is still not enough, throw error
            if (getInputAssetSum(assetId) < BigInt(_amount)) {
                throw new Error(`Insufficient balance for asset ${assetId}. Required: ${_amount}, Available: ${getInputAssetSum(assetId)}`);
            }
            const excessAssetValue = getInputAssetSum(assetId) - BigInt(_amount);
            if (excessAssetValue > 0) {
                // TODO handle excess asset input
                // - add excess amount transfer tx into transfer.transfers
                tx?.transfer?.transfers.push({
                    asset: asset,
                    amount: client.forceCompression || client.network != "regtest"
                        ? (0, utils_1.encodeVaruint)(excessAssetValue)
                        : excessAssetValue.toString(),
                    output: client.forceCompression || client.network != "regtest" ? (0, utils_1.encodeVaruint)(outputs.length) : outputs.length,
                });
                // - add output for excess amount to the sender address
                outputs.push({
                    value: 546,
                    address: address,
                });
                txBytes += (0, fee_1.getOutputBytes)({
                    value: 546,
                    address: address,
                });
                totalFee = feeRate * txBytes;
                // - make sure the transfer index and output is matched
            }
        }
    }
    // // TODO handle mint, add output from mint pointer
    // if (_isTxContainsMintContractCall(tx)) {
    //   const mintCall = _isTxContainsMintContractCall(tx);
    //   if (!mintCall) throw new Error("Mint TX invalid");
    // }
    if (totalInputValue < totalOutputValue + totalFee) {
        addUtxosToInputs(nonUtxosGlittr, feeRate);
    }
    // TODO handle multiple utxo type in one array
    let utxoInputs = [];
    const addressType = (0, address_1.getAddressType)(address);
    for (const utxo of inputs) {
        switch (addressType) {
            case bitcoin_address_validation_1.AddressType.p2pkh:
            case bitcoin_address_validation_1.AddressType.p2sh:
                const txHex = await (0, electrum_1.electrumFetchTxHex)(client.electrumApi, client.apiKey, utxo.txid);
                utxoInputs.push({
                    hash: utxo.txid,
                    index: utxo.vout,
                    nonWitnessUtxo: Buffer.from(txHex, "hex"),
                });
                break;
            case bitcoin_address_validation_1.AddressType.p2wpkh:
                const paymentOutput = bitcoinjs_lib_1.payments.p2wpkh({
                    address,
                    network: (0, utils_1.getBitcoinNetwork)(client.network),
                }).output;
                utxoInputs.push({
                    hash: utxo.txid,
                    index: utxo.vout,
                    witnessUtxo: {
                        script: paymentOutput,
                        value: utxo.value,
                    },
                });
                break;
            case bitcoin_address_validation_1.AddressType.p2tr:
                const p2trOutput = bitcoinjs_lib_1.payments.p2tr({
                    address,
                    network: (0, utils_1.getBitcoinNetwork)(client.network),
                }).output;
                utxoInputs.push({
                    hash: utxo.txid,
                    index: utxo.vout,
                    witnessUtxo: {
                        script: p2trOutput,
                        value: utxo.value,
                    },
                    tapInternalKey: publicKey
                        ? Buffer.from(publicKey, "hex").subarray(1, 33)
                        : undefined,
                });
                break;
        }
    }
    // Finalize
    let changeFee = exports.FEE_TX_OUTPUT_BASE + exports.FEE_TX_OUTPUT_PUBKEYHASH;
    if (changeOutputAddress) {
        changeFee = (0, fee_1.getOutputBytes)({ address, value: 0 }); // value: 0 is dummy
    }
    const bytesAccum = (0, fee_1.getTransactionBytes)(inputs, outputs);
    const feeAfterExtraOutput = feeRate * (bytesAccum + changeFee);
    const remainderAfterExtraOutput = inputs.reduce((prev, input) => prev + input.value, 0) -
        (outputs.reduce((prev, output) => prev + output.value, 0) +
            feeAfterExtraOutput);
    if (changeOutputAddress &&
        remainderAfterExtraOutput > dustThreshold(feeRate)) {
        outputs.push({
            address: changeOutputAddress,
            value: remainderAfterExtraOutput,
        });
    }
    const fee = _sumValues(inputs) - _sumValues(outputs);
    if (!isFinite(fee))
        return { fee: feeRate * bytesAccum };
    const txFee = (0, fee_1.getTransactionBytes)(inputs, outputs) * feeRate;
    return { inputs: utxoInputs, outputs, fee, txFee, tx };
}
exports.coinSelect = coinSelect;
function dustThreshold(feeRate) {
    return exports.FEE_TX_INPUT_BASE + exports.FEE_TX_INPUT_PUBKEYHASH * feeRate;
}
exports.dustThreshold = dustThreshold;
