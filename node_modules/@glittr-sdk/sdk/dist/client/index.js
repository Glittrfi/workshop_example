"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlittrSDK = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const coinselect_1 = require("./coinselect");
const utils_1 = require("../utils");
const address_1 = require("../utils/address");
const bitcoin_address_validation_1 = require("bitcoin-address-validation");
const fetch_1 = require("../utils/fetch");
const electrum_1 = require("../utils/electrum");
const transaction_1 = require("../transaction");
class GlittrSDK {
    network;
    apiKey;
    glittrApi;
    electrumApi;
    forceCompression = false;
    constructor({ network, apiKey, glittrApi, electrumApi, forceCompression, }) {
        this.network = network;
        this.apiKey = apiKey;
        this.glittrApi = glittrApi;
        this.electrumApi = electrumApi;
        if (forceCompression)
            this.forceCompression = forceCompression;
    }
    async createTx({ address, tx, outputs, utxos, publicKey, }) {
        outputs = outputs ?? [];
        const addressType = (0, address_1.getAddressType)(address);
        const embed = this.forceCompression || this.network != "regtest"
            ? await transaction_1.txBuilder.compress(tx)
            : transaction_1.txBuilder.compile(tx);
        outputs = outputs.concat({ script: embed, value: 0 });
        const psbt = new bitcoinjs_lib_1.Psbt({ network: (0, utils_1.getBitcoinNetwork)(this.network) });
        const coins = await (0, coinselect_1.coinSelect)(this, utxos ?? [], outputs, 2, address, tx, address, publicKey);
        const _inputs = coins?.inputs ?? [];
        for (const input of _inputs) {
            switch (addressType) {
                case bitcoin_address_validation_1.AddressType.p2pkh:
                    psbt.addInput({
                        hash: input.hash,
                        index: input.index,
                        nonWitnessUtxo: input.nonWitnessUtxo,
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2sh:
                    // NOTE: P2SH-P2WPKH for xverse (nested segwit)
                    const decodedPublicKey = Buffer.from(publicKey, "hex");
                    const p2wpkh = bitcoinjs_lib_1.payments.p2wpkh({
                        pubkey: decodedPublicKey,
                        network: (0, utils_1.getBitcoinNetwork)(this.network),
                    });
                    const p2sh = bitcoinjs_lib_1.payments.p2sh({
                        redeem: p2wpkh,
                        network: (0, utils_1.getBitcoinNetwork)(this.network),
                    });
                    psbt.addInput({
                        hash: input.hash,
                        index: input.index,
                        nonWitnessUtxo: input.nonWitnessUtxo,
                        redeemScript: p2sh.redeem?.output,
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2wpkh:
                    psbt.addInput({
                        hash: input.hash,
                        index: input.index,
                        witnessUtxo: input.witnessUtxo,
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2tr:
                    psbt.addInput({
                        hash: input.hash,
                        index: input.index,
                        witnessUtxo: input.witnessUtxo,
                        tapInternalKey: input.tapInternalKey,
                    });
                    break;
                default:
                    throw new Error(`Error Address Type not supported yet`);
            }
        }
        const _outputs = coins?.outputs ?? [];
        for (const output of _outputs) {
            if (output.address) {
                psbt.addOutput({ address: output.address, value: output.value });
            }
            else if (output.script) {
                psbt.addOutput({ script: output.script, value: output.value });
            }
        }
        return psbt;
    }
    async broadcastTx(hex) {
        // Validate Glittr TX
        const isValidGlittrTx = await (0, fetch_1.fetchPOST)(`${this.glittrApi}/validate-tx`, {}, hex);
        if (!isValidGlittrTx.is_valid)
            throw new Error(`Invalid Glittr TX Format : ${JSON.stringify(isValidGlittrTx)}`);
        // Broadcast TX
        const txId = await (0, fetch_1.fetchPOST)(`${this.electrumApi}/tx`, {}, hex);
        return txId;
    }
    async createAndBroadcastTx({ account, tx, outputs, utxos, }) {
        outputs = outputs ?? [];
        const addressType = (0, address_1.getAddressType)(account.address);
        const embed = this.forceCompression || this.network != "regtest"
            ? await transaction_1.txBuilder.compress(tx)
            : transaction_1.txBuilder.compile(tx);
        outputs = [{ script: embed, value: 0 }, ...outputs];
        const psbt = new bitcoinjs_lib_1.Psbt({ network: (0, utils_1.getBitcoinNetwork)(this.network) });
        const coins = await (0, coinselect_1.coinSelect)(this, utxos ?? [], outputs, 2, account.address, tx, account.address, account.keypair.publicKey.toString("hex"));
        const _inputs = coins?.inputs ?? [];
        for (const input of _inputs) {
            switch (addressType) {
                case bitcoin_address_validation_1.AddressType.p2pkh:
                case bitcoin_address_validation_1.AddressType.p2sh:
                    psbt.addInput({
                        hash: input.hash,
                        index: input.index,
                        nonWitnessUtxo: input.nonWitnessUtxo,
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2wpkh:
                    psbt.addInput({
                        hash: input.hash,
                        index: input.index,
                        witnessUtxo: input.witnessUtxo,
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2tr:
                    psbt.addInput({
                        hash: input.hash,
                        index: input.index,
                        witnessUtxo: input.witnessUtxo,
                        tapInternalKey: input.tapInternalKey,
                    });
                    break;
                default:
                    throw new Error(`Error Address Type not supported yet`);
            }
        }
        const _outputs = coins?.outputs ?? [];
        for (const output of _outputs) {
            if (output.address) {
                psbt.addOutput({ address: output.address, value: output.value });
            }
            else if (output.script) {
                psbt.addOutput({ script: output.script, value: output.value });
            }
        }
        if (addressType === bitcoin_address_validation_1.AddressType.p2tr) {
            const tweakedSigner = account.keypair.tweak(bitcoinjs_lib_1.crypto.taggedHash("TapTweak", account.keypair.publicKey.subarray(1, 33)));
            psbt.signAllInputs(tweakedSigner);
        }
        else {
            psbt.signAllInputs(account.keypair);
            const isValidSignature = psbt.validateSignaturesOfAllInputs(utils_1.validator);
            if (!isValidSignature) {
                throw new Error(`Error signature invalid`);
            }
        }
        psbt.finalizeAllInputs();
        const hex = psbt.extractTransaction(true).toHex();
        // Validate Glittr TX
        const isValidGlittrTx = await (0, fetch_1.fetchPOST)(`${this.glittrApi}/validate-tx`, {}, hex);
        if (!isValidGlittrTx.is_valid)
            throw new Error(`Invalid Glittr TX Format : ${JSON.stringify(isValidGlittrTx)}`);
        // Broadcast TX
        const txId = await (0, fetch_1.fetchPOST)(`${this.electrumApi}/tx`, {}, hex);
        return txId;
    }
    async createAndBroadcastRawTx({ account, inputs, outputs, }) {
        const addressType = (0, address_1.getAddressType)(account.address);
        if (inputs && inputs.length === 0) {
            throw new Error("No inputs provided");
        }
        if (outputs && outputs.length === 0) {
            throw new Error("No outputs provided");
        }
        const psbt = new bitcoinjs_lib_1.Psbt({ network: (0, utils_1.getBitcoinNetwork)(this.network) });
        for (const input of inputs) {
            switch (addressType) {
                case bitcoin_address_validation_1.AddressType.p2pkh:
                    const txHex = await (0, electrum_1.electrumFetchTxHex)(this.electrumApi, this.apiKey, input.txid);
                    psbt.addInput({
                        hash: input.txid,
                        index: input.vout,
                        nonWitnessUtxo: Buffer.from(txHex, "hex"),
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2wpkh:
                    const paymentOutput = bitcoinjs_lib_1.payments.p2wpkh({
                        address: account.address,
                        network: (0, utils_1.getBitcoinNetwork)(this.network),
                    }).output;
                    psbt.addInput({
                        hash: input.txid,
                        index: input.vout,
                        witnessUtxo: {
                            script: paymentOutput,
                            value: input.value,
                        },
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2tr:
                    const tapInternalKey = account.keypair.publicKey.subarray(1, 33);
                    const p2trPayments = bitcoinjs_lib_1.payments.p2tr({
                        address: account.address,
                        network: (0, utils_1.getBitcoinNetwork)(this.network),
                        internalPubkey: tapInternalKey,
                    });
                    const p2trOutput = p2trPayments.output;
                    psbt.addInput({
                        hash: input.txid,
                        index: input.vout,
                        witnessUtxo: {
                            script: p2trOutput,
                            value: input.value,
                        },
                        tapInternalKey,
                    });
            }
        }
        for (const output of outputs) {
            if (output.address) {
                psbt.addOutput({ address: output.address, value: output.value });
            }
            else if (output.script) {
                psbt.addOutput({ script: output.script, value: output.value });
            }
        }
        if (addressType === bitcoin_address_validation_1.AddressType.p2tr) {
            const tweakedSigner = account.keypair.tweak(bitcoinjs_lib_1.crypto.taggedHash("TapTweak", account.keypair.publicKey.subarray(1, 33)));
            psbt.signAllInputs(tweakedSigner);
        }
        else {
            psbt.signAllInputs(account.keypair);
            const isValidSignature = psbt.validateSignaturesOfAllInputs(utils_1.validator);
            if (!isValidSignature) {
                throw new Error(`Error signature invalid`);
            }
        }
        psbt.finalizeAllInputs();
        const hex = psbt.extractTransaction(true).toHex();
        // Validate Glittr TX
        const isValidGlittrTx = await (0, fetch_1.fetchPOST)(`${this.glittrApi}/validate-tx`, {}, hex);
        if (!isValidGlittrTx.is_valid)
            throw new Error(`Invalid Glittr TX Format : ${JSON.stringify(isValidGlittrTx)}`);
        // console.error(`Invalid Glittr TX Format : ${isValidGlittrTx}`)
        const txId = await (0, fetch_1.fetchPOST)(`${this.electrumApi}/tx`, { Authorization: `Bearer ${this.apiKey}` }, hex);
        return txId;
    }
    async createRawTx({ address, inputs, outputs, publicKey, }) {
        const addressType = (0, address_1.getAddressType)(address);
        if (inputs && inputs.length === 0) {
            throw new Error("No inputs provided");
        }
        if (outputs && outputs.length === 0) {
            throw new Error("No outputs provided");
        }
        const psbt = new bitcoinjs_lib_1.Psbt({ network: (0, utils_1.getBitcoinNetwork)(this.network) });
        for (const input of inputs) {
            switch (addressType) {
                case bitcoin_address_validation_1.AddressType.p2pkh:
                    const txHex = await (0, electrum_1.electrumFetchTxHex)(this.electrumApi, this.apiKey, input.txid);
                    psbt.addInput({
                        hash: input.txid,
                        index: input.vout,
                        nonWitnessUtxo: Buffer.from(txHex, "hex"),
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2wpkh:
                    const paymentOutput = bitcoinjs_lib_1.payments.p2wpkh({
                        address,
                        network: (0, utils_1.getBitcoinNetwork)(this.network),
                    }).output;
                    psbt.addInput({
                        hash: input.txid,
                        index: input.vout,
                        witnessUtxo: {
                            script: paymentOutput,
                            value: input.value,
                        },
                    });
                    break;
                case bitcoin_address_validation_1.AddressType.p2tr:
                    const tapInternalKey = Buffer.from(publicKey, "hex").subarray(1, 33);
                    const p2trPayments = bitcoinjs_lib_1.payments.p2tr({
                        address,
                        network: (0, utils_1.getBitcoinNetwork)(this.network),
                        internalPubkey: tapInternalKey,
                    });
                    const p2trOutput = p2trPayments.output;
                    psbt.addInput({
                        hash: input.txid,
                        index: input.vout,
                        witnessUtxo: {
                            script: p2trOutput,
                            value: input.value,
                        },
                        tapInternalKey,
                    });
            }
        }
        for (const output of outputs) {
            if (output.address) {
                psbt.addOutput({ address: output.address, value: output.value });
            }
            else if (output.script) {
                psbt.addOutput({ script: output.script, value: output.value });
            }
        }
        return psbt;
    }
}
exports.GlittrSDK = GlittrSDK;
