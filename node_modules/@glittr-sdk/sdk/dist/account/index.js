"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const ecpair_1 = require("../utils/ecpair");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const network_1 = require("../utils/network");
class Account {
    keypair;
    network;
    constructor({ privateKey, wif, network }) {
        this.keypair = ecpair_1.ecpair.makeRandom();
        if (privateKey) {
            const privateKeyBuffer = Buffer.from(privateKey, "hex");
            this.keypair = ecpair_1.ecpair.fromPrivateKey(privateKeyBuffer, {
                network: (0, network_1.getBitcoinNetwork)(network),
            });
        }
        if (wif) {
            this.keypair = ecpair_1.ecpair.fromWIF(wif, (0, network_1.getBitcoinNetwork)(network));
        }
        this.network = network;
    }
    p2pkh() {
        const p2pkhPayments = bitcoinjs_lib_1.payments.p2pkh({
            pubkey: this.keypair.publicKey,
            network: (0, network_1.getBitcoinNetwork)(this.network),
        });
        return {
            address: p2pkhPayments.address,
            keypair: this.keypair,
        };
    }
    p2wpkh() {
        const p2wpkhPayments = bitcoinjs_lib_1.payments.p2wpkh({
            pubkey: this.keypair.publicKey,
            network: (0, network_1.getBitcoinNetwork)(this.network),
        });
        return {
            address: p2wpkhPayments.address,
            keypair: this.keypair,
        };
    }
    p2tr() {
        const p2trPayments = bitcoinjs_lib_1.payments.p2tr({
            internalPubkey: this.keypair.publicKey.slice(1, 33),
            network: (0, network_1.getBitcoinNetwork)(this.network),
        });
        return {
            address: p2trPayments.address,
            keypair: this.keypair,
        };
    }
}
exports.Account = Account;
