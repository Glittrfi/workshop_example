"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addFeeToTx = exports.getTransactionBytes = exports.getOutputBytes = exports.getInputBytes = exports.getFeeRate = void 0;
const coinselect_1 = require("../client/coinselect");
const DEFAULT_FEE_RATES = {
    MAINNET: {
        HIGH: 25,
        MEDIUM: 15,
        LOW: 5
    },
    TESTNET: {
        HIGH: 10,
        MEDIUM: 5,
        LOW: 1
    },
    REGTEST: {
        HIGH: 1,
        MEDIUM: 1,
        LOW: 1
    }
};
async function getFeeRate(network, level, mempoolUrl) {
    // For regtest, always use minimal fee rate
    if (network === 'regtest') {
        return DEFAULT_FEE_RATES.REGTEST[level || 'MEDIUM'];
    }
    // For mainnet/testnet, try to get from mempool if URL provided
    if (mempoolUrl) {
        try {
            const response = await fetch(mempoolUrl);
            const fees = await response.json();
            switch (level) {
                case 'HIGH':
                    return fees.fastestFee;
                case 'MEDIUM':
                    return fees.halfHourFee;
                case 'LOW':
                    return fees.minimumFee;
            }
        }
        catch (error) {
            console.warn('Failed to fetch fee rates, using defaults');
        }
    }
    // Cast the network string to the correct type
    const networkKey = network.toUpperCase();
    return DEFAULT_FEE_RATES[networkKey][level || 'MEDIUM'];
}
exports.getFeeRate = getFeeRate;
function getInputBytes(input) {
    let bytes = coinselect_1.FEE_TX_INPUT_BASE;
    if (input.redeemScript) {
        bytes += input.redeemScript.length;
    }
    if (input.witnessScript) {
        bytes += Math.ceil(input.witnessScript.byteLength / 4);
    }
    else if (input.isTaproot) {
        if (input.taprootWitness) {
            bytes += Math.ceil(coinselect_1.FEE_TX_INPUT_TAPROOT +
                input.taprootWitness.reduce((prev, buffer) => prev + buffer.byteLength, 0) /
                    4);
        }
        else {
            bytes += coinselect_1.FEE_TX_INPUT_TAPROOT;
        }
    }
    else if (input.witnessUtxo) {
        bytes += coinselect_1.FEE_TX_INPUT_SEGWIT;
    }
    else if (!input.redeemScript) {
        bytes += coinselect_1.FEE_TX_INPUT_PUBKEYHASH;
    }
    return bytes;
}
exports.getInputBytes = getInputBytes;
function getOutputBytes(output) {
    let bytes = coinselect_1.FEE_TX_OUTPUT_BASE;
    if (output.script) {
        bytes += output.script.byteLength;
    }
    else if (output.address?.startsWith("bc1") || // mainnet
        output.address?.startsWith("tb1") || // testnet
        output.address?.startsWith("bcrt1") // regtest
    ) {
        // 42 for mainnet/testnet, 44 for regtest
        if (output.address?.length === 42 || output.address?.length === 44) {
            bytes += coinselect_1.FEE_TX_OUTPUT_SEGWIT;
        }
        else {
            // taproot fee approximate is same like p2wsh (2 of 3 multisig)
            bytes += coinselect_1.FEE_TX_OUTPUT_SEGWIT_SCRIPTHASH;
        }
        // both testnet and regtest has the same prefix 2
    }
    else if (output.address?.startsWith("3") ||
        output.address?.startsWith("2")) {
        bytes += coinselect_1.FEE_TX_OUTPUT_SCRIPTHASH;
    }
    else {
        bytes += coinselect_1.FEE_TX_OUTPUT_PUBKEYHASH;
    }
    return bytes;
}
exports.getOutputBytes = getOutputBytes;
function getTransactionBytes(inputs, outputs) {
    return (coinselect_1.FEE_TX_EMPTY_SIZE +
        inputs.reduce((prev, input) => prev + getInputBytes(input), 0) +
        outputs.reduce((prev, output) => prev + getOutputBytes(output), 0));
}
exports.getTransactionBytes = getTransactionBytes;
async function addFeeToTx(network, address, utxos, inputs, outputs) {
    const feeRate = await getFeeRate(network);
    const txBytes = getTransactionBytes(inputs, outputs);
    const totalFee = feeRate * txBytes;
    for (const utxo of utxos) {
        if (inputs.some(input => input.txid === utxo.txid && input.vout === utxo.vout))
            continue;
        inputs.push(utxo);
        const totalInputValue = inputs.reduce((prev, input) => prev + input.value, 0);
        const totalOutputValue = outputs.reduce((prev, output) => prev + output.value, 0);
        if (totalInputValue >= totalOutputValue + totalFee + 1000)
            break;
    }
    // Calculate change amount
    const changeAmountBytes = coinselect_1.FEE_TX_OUTPUT_BASE + coinselect_1.FEE_TX_OUTPUT_PUBKEYHASH;
    const txBytesAfterFee = getTransactionBytes(inputs, outputs);
    const feeWithChangeAmount = feeRate * (txBytesAfterFee + changeAmountBytes);
    const remainderAfterChangeAmount = inputs.reduce((prev, input) => prev + input.value, 0) -
        (outputs.reduce((prev, output) => prev + output.value, 0) + feeWithChangeAmount + totalFee);
    const changeFee = feeRate * (coinselect_1.FEE_TX_OUTPUT_BASE + coinselect_1.FEE_TX_OUTPUT_PUBKEYHASH);
    if (remainderAfterChangeAmount > 546 && remainderAfterChangeAmount > changeFee) {
        outputs.push({
            address,
            value: remainderAfterChangeAmount
        });
    }
    // Final validation temporary disabled
    // const finalTxBytes = getTransactionBytes(inputs, outputs);
    // const finalFee = inputs.reduce((prev, input) => prev + input.value, 0) -
    //   outputs.reduce((prev, output) => prev + output.value, 0);
    // if (finalFee / finalTxBytes < 1) {
    //   throw new Error('Transaction fee rate too low. Minimum required is 1 sat/vbyte.');
    // }
    return { inputs, outputs };
}
exports.addFeeToTx = addFeeToTx;
